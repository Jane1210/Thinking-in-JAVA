# 第七章 复用类

两种方法实现代码重用机制：

- [ ] 组合：在新的类中产生现有类的对象。

- [ ] 继承：按照现有类的形式创建新类。

## 一 组合

初始化引用可以在以下4个位置进行：

- 在定义对象的地方。它在构造器调用之前被初始化。

- 在类的构造器中。

- 在正要使用这些对象之前，即惰性初始化。

- 使用实例初始化。

## 二 继承

一个类，除非明确指出继承了其他类，否则都是隐式继承了根类 Object.

为了继承，一般规则是将所有的数据成员指定为 private，将所有的方法指定为 public.

当创建了一个子类对象时，该对象包含了一个基类的子对象。

当基类构造器带参数时，需要在子类构造器中通过将 super(i) 放在第一行显示调用基类构造器。

存在继承时，初始化顺序为：

- 父类（静态变量、静态语句块）
- 子类（静态变量、静态语句块）
- 父类（实例变量、普通语句块）
- 父类（构造函数）
- 子类（实例变量、普通语句块）
- 子类（构造函数）

注意，在清理方法中，清理顺序与生成顺序相反（以防某个子对象依赖于另一个子对象）。

## 三 代理

Java 语言不直接支持代理，但是，使用代理可以让我们拥有更多的控制力，因为我们可以选择只提供在成员对象中的方法的某个子集。

## 四 组合和继承的结合使用

#### 组合

通常用于想在新类中使用现有类的功能而非它的接口这种情形。即，在新类中嵌入某个对象，让其实现所需要的功能，但新类的用户看到的只是为新类所定义的接口，而非所嵌入的对象的接口。为取得此效果，需要在新类中嵌入一个现有类的 private 对象。（特例，汽车和组件问题，这里将成员对象如车轮、引擎等设置为 public 将有助于客户端程序员了解怎样去使用类。）

- "is-a"(是一个)的关系用继承
- "has-a"(有一个)的关系用组合

#### 向上转型

记住 “子类是父类的一种类型，子类对象也是一种父类对象” 即可。

继承应该慎用！！！

用组合还是继承，只需要问一句 “需要向上转型吗”，如果是，那就继承吧。

## 五 final 关键字

#### 1.final 数据

- 修饰基本类型：使数值恒定不变

- 修饰对象引用：使引用恒定不变。即一旦引用被初始化指向一个对象，无法再把它改为指向另一个对象，不过对象本身是可以被修改的。

static final 域（编译期常量）只占据一段不能改变的内存空间。

static final 域用大写表示，并用下划线分割单词，如 public static final int VALUE_ONE = 1000；

并不能因为某数据是 final 的就可以在编译时知道它的值，在运行时使用随机生成的数值来初始化也是可能的。

带有恒定初始值的 final 基本类型即编译期常量。

**空白final**

​	指被声明为 final 但又未给定初始值的域。但是编译期一定会确保空白 final 在使用前被初始化。

​	通常，在构造器中初始化空白 final，这样，既做到 final 域因对象而不同，对每个对象而言又保持恒定不变。

**final 参数**

​	参数列表被 final 修饰，则参数无法修改。主要用来向匿名内部类传递数据，后面学。

#### 2.final 方法

锁定方法，不能被继承它的子类所覆盖。

类中所有的 private 方法都隐式地指定为 final 的。你试图覆盖一个private 方法，编译期并不会报错，但不能说是覆盖，因为此时该父类中的 private 方法并不是基类的接口，覆盖是基于接口的概念。

#### 3.final 类

该类不能被继承。

## 六 初始化及类的加载

不管一个编译单元有几个 class，每个 class 的编译代码都存在于它自己的独立的文件中，该文件只在需要使用程序代码时才会被加载。一般来说，“类的代码在初次使用时才加载”，通常是指创建类的第一个对象时，或者访问 static 域或 static 方法时。

存在继承时，当子类上运行 java 时，先访问 main()，于是加载器开始启动并找出子类的编译代码（在子类的 .class 文件中）。加载过程中，编译器由 extends 关键字得知它有基类，于是继续进行加载，不管是否生成了子类的对象，这都发生。如果向上还有基类，继续加载直到根基类。接下来，根基类中的 static 初始化，然后是下一个导出类，以此类推。

这样，必要的类都加载完毕，对象可以被创建了。首先初始化基本类型，对象引用被设为 null，然后调用基类构造器。



