# 第八章 多态

“封装”是通过合并特征和行为来创建新的数据类型；“实现隐藏”是通过将细节“私有化”把接口和实现分离开来；

多态则是消除类型之间的耦合关系。

## 一 “绑定”的概念

将一个方法调用同一个方法主体关联起来称为绑定。

**前期绑定**：程序执行之前绑定。

**后期绑定**：在运行时根据对象的类型进行绑定。又叫动态绑定，或运行时绑定。

Java 中除了 static 方法和 final 方法（private 方法也属于 final 方法），其他所有方法都是后期绑定。

- 因为 private 默认是 final 的，所以只有非 private 方法才能被覆盖，“表面覆盖”并不会达到预期效果。

- 域不是多态的。new 一个子类对象，向上转型后，该对象访问的域还是基类的。（一般不用考虑，因为一般不会把域定义为 public 的，也不会把子类和父类的域用相同的名字）

- 静态方法不是多态的。子类方法即使覆盖了覆盖了父类的静态方法也没用。

- 只有只有普通方法调用可以是多态的。

## 二 构造器和多态

构造器不具有多态性，因为它是隐式 static 的。自上而下，层层调用。

如果遇到清理问题（一般不会），对于依赖于基类的对象，清理顺序要与初始化顺序相反；对于字段，与声明顺序相反；对于类，先清理导出类，后清理基类。

#### 引用计数

当成员对象中存在其他一个或多个对象共享的情况，就必须要用引用计数来跟踪仍旧访问着共享对象的对象数量，从而知道何时释放被共享的成员对象。

#### 构造器内部的多态方法的行为

在基类构造器中调用多态方法，的确会调用到子类的方法，但是输出结果都是0. 这是因为，初始化的实际过程是：

1. 在其他任何事物发生之前，将分配给对象的存储空间初始化为二进制的零。
2. 调用基类构造器。
3. 按照声明的顺序调用成员的初始化方法。
4. 调用导出类的构造器主体。

因此，在构造器中轻易不要调用其他方法，唯一安全的是基类的 final （private 也是 final）方法，因为不会被覆盖。

## 三 协变返回类型

Java SE5 中添加的该类型。

表示在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型。

```
class Grain {
	String toString() {return "Grain";}
class Wheat extends Grain {
	String toString() {return "Wheat";}
}
class Mill {
    Grain process() {return new Grain();}
}
class WheatMill extends Mill {
    Wheat process() {return new Wheat();}
}
```



## 四 用继承进行设计

通用准则：“用继承表达行为间的差异，并用字段表达状态上的变化”。

继承和组合相结合。

#### 向下转型

想访问子类中扩展的接口时，需要向下转型。

如果所转类型是正确的，则转型成功；否则，返回 ClassCastException 异常。
